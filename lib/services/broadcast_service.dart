import 'package:jawara_pintar_kel_5/models/kegiatan/broadcast_model.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class BroadcastService {
  final SupabaseClient _supabase = Supabase.instance.client;
  final String _tableName = 'broadcast';

  Stream<List<BroadcastModel>> getBroadcastsStream() {
    return _supabase
        .from(_tableName)
        .stream(primaryKey: ['id'])
        .order('tanggal', ascending: false)
        .map((maps) => maps.map((map) => BroadcastModel.fromMap(map)).toList());
  }

  /// Fetch semua broadcast
  Future<List<BroadcastModel>> getBroadcasts() async {
    try {
      final response =
          await _supabase.from(_tableName).select().order('tanggal', ascending: false);
      return List<BroadcastModel>.from(
          response.map((json) => BroadcastModel.fromMap(json)));
    } catch (e) {
      throw Exception('Error fetching broadcasts: $e');
    }
  }

  /// Fetch broadcast by ID
  Future<BroadcastModel> getBroadcastById(int id) async {
    try {
      final response = await _supabase
          .from(_tableName)
          .select()
          .eq('id', id)
          .single();
      return BroadcastModel.fromMap(response);
    } catch (e) {
      throw Exception('Error fetching broadcast by id: $e');
    }
  }

  /// Create broadcast baru
  Future<BroadcastModel> createBroadcast(BroadcastModel broadcast) async {
    try {
      // Omitting id and created_at because they are generated by the database
      final Map<String, dynamic> insertData = broadcast.toMap()
        ..remove('id')
        ..remove('created_at');

      final response = await _supabase
          .from(_tableName)
          .insert(insertData)
          .select()
          .single();

      return BroadcastModel.fromMap(response);
    } catch (e) {
      throw Exception('Error creating broadcast: $e');
    }
  }

  /// Update broadcast
  Future<BroadcastModel> updateBroadcast(int id, BroadcastModel broadcast) async {
    try {
      // Omitting id and created_at because they should not be updated
      final Map<String, dynamic> updateData = broadcast.toMap()
        ..remove('id')
        ..remove('created_at');

      final response = await _supabase
          .from(_tableName)
          .update(updateData)
          .eq('id', id)
          .select()
          .single();

      return BroadcastModel.fromMap(response);
    } catch (e) {
      throw Exception('Error updating broadcast: $e');
    }
  }

  /// Delete broadcast
  Future<void> deleteBroadcast(int id) async {
    try {
      await _supabase.from(_tableName).delete().eq('id', id);
    } catch (e) {
      throw Exception('Error deleting broadcast: $e');
    }
  }
}
